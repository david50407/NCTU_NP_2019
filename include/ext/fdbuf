#if !defined(__EXT_FDBUF__)
#define __EXT_FDBUF__

#include <unistd.h>
#include <streambuf>

namespace ext {
	class fdbuf : public std::streambuf
	{
		public:
			fdbuf() = delete;
			fdbuf(int fd) : __fd(fd), __isopen(true) {}
			~fdbuf() {
				close();
			}

			bool is_open() const { return __isopen; };
			fdbuf* close() {
				if (!is_open()) {
					return nullptr;
				}

				if (::close(__fd) == -1) {
					return nullptr;
				}

				return this;
			}
			int fd() { return __fd; };

		protected:
			int_type underflow() {
				if (gptr() == egptr()) {
					int size = ::read(__fd, __inbuf, BUFFER_SIZE);
					if (size < 1) {
						return traits_type::eof();
					}
					setg(__inbuf, __inbuf, __inbuf + BUFFER_SIZE);
				}
				return traits_type::to_int_type(*gptr());
			}
			int_type overflow(int_type c) {
				// As we are not going to impl. out buffer,
				// let overflow always happens.
				return traits_type::eof();
			}

		private:
			static std::streamsize const BUFFER_SIZE = 1024;
			int __fd;
			bool __isopen;
			char __inbuf[BUFFER_SIZE];
	};
}; // namespace ext

#endif // !defined(__EXT_FDBUF__)